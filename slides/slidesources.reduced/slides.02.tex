\part{Architectures}
\section{Architectural styles}
\begin{slide}{Architectural styles}
  \begin{block}{Basic idea}
    A style is formulated in terms of
    \begin{itemize}\tightlist
      \item (replaceable) components with well-defined interfaces
      \item the way that components are connected to each other
      \item the data exchanged between components
      \item how these components and connectors are jointly configured into a system.
    \end{itemize}
  \end{block}
  \begin{block}{Connector}
    A mechanism that mediates communication, coordination, or cooperation among components. \textbf{Example}:
    facilities for (remote) procedure call, messaging, or streaming.
  \end{block}
\end{slide}
\section{Layered architectures}
\begin{slide}{Layered architecture}
  \begin{block}{Different layered organizations}
    \begin{center}
      \begin{tabular}{ccc}
        \includefigure[0.75]{02-01a} &
        \includefigure[0.75]{02-01b} &
        \includefigure[0.75]{02-01c}                      \\
        (a)                          & (b) & (c) callback \\
      \end{tabular}
    \end{center}
  \end{block}
  Note in (c) the \textbf{handle} downward call does not return data.
  The upward callback is a separate invocation.
  No call/return pairing across layers, ulike the others.
\end{slide}

\begin{slide}{Application Layering}
  \begin{block}{Traditional three-layered view}
    \begin{itemize}\tightlist
      \item \textbf{Application-interface layer} contains units for interfacing to users or external applications
      \item \textbf{Processing layer} contains the functions of an application, i.e., without specific data
      \item \textbf{Data layer} contains the data that a client wants to manipulate through the application
            components
    \end{itemize}
  \end{block}
  \onslide
  \begin{alertblock}{Observation}
    This layering is found in many distributed information systems, using traditional database technology and
    accompanying applications.
  \end{alertblock}
\end{slide}
\begin{slide}{Application Layering}
  \begin{block}{Example: a simple search engine}
    \begin{center}
      \includefigure{02-04}
    \end{center}
  \end{block}
\end{slide}
\section{RPC and REST Architectures}
\begin{slide}{RPC - Object-based style}
  \begin{block}{Essence}
    Components are objects, connected to each other through procedure calls. Objects may be placed on
    different machines; calls can thus execute across a network. This
    is known as a Remote Procedure Call (RPC)
  \end{block}
  \begin{block}{}
    \begin{tabular}{c@{\hspace*{24pt}}c}
      \includefigure{02-05a} &
      \includefigure{02-05b}   \\
    \end{tabular}
  \end{block}
  \begin{block}{Encapsulation}
    Objects are said to \textbf{encapsulate data} and offer \textbf{methods on that data} without revealing the
    internal implementation.
  \end{block}
\end{slide}
\begin{slide}{RESTful architectures}
  \begin{block}{Essence}
    \begin{enumerate}\tightlist
      \item \textbf{Architectural Style}: REST is an architectural style for networked applications, focusing on stateless, client-server communication over HTTP, designed for scalability and simplicity.
      \item \textbf{Resource-Based}: Resources in REST are uniquely identified by URIs and manipulated using standard HTTP methods such as GET, POST, PUT, DELETE, and PATCH.
      \item \textbf{Statelessness}: Each client request to the server is independent, containing all necessary information, eliminating server-side session state to enhance scalability.
      \item \textbf{Layered System}: REST employs a layered architecture, allowing intermediaries like proxies or load balancers to improve performance and security transparently.
      \item \textbf{Cacheability}: REST responses can be cached when explicitly defined, improving performance by reducing server load and latency for frequently accessed resources.
    \end{enumerate}
  \end{block}
\end{slide}
\begin{slide}{REST Services}
  \begin{block}{Basic operations}\scriptsize
    \begin{center}
      \begin{tabular}{|l|l|} \hline
        \textbf{Operation} & \textbf{Description}                                    \\ \whline
        \code{PUT}         & Create a new resource                                   \\ \hline
        \code{GET}         & Retrieve the state of a resource in some representation \\ \hline
        \code{DELETE}      & Delete a resource                                       \\ \hline
        \code{POST}        & Modify a resource by transferring a new state           \\ \hline
      \end{tabular}
    \end{center}
  \end{block}
  \begin{itemize}
    \item REST is a scalable, stateless architectural style for networked applications using HTTP.
    \item It focuses on resources identified by URIs, manipulated via standard methods (GET, POST, PUT, DELETE).
    \item Features a layered, cacheable design to enhance performance and flexibility.
  \end{itemize}
\end{slide}
\begin{slide}{Example: Amazon's Simple Storage Service}
  \begin{block}{Essence}
    \textbf{Objects} (i.e., files) are placed into \textbf{buckets} (i.e., directories). Buckets cannot be placed
    into buckets. Operations on \code{ObjectName} in bucket \code{BucketName} require the following
    identifier:
    \begin{center}
      \code{http://BucketName.s3.amazonaws.com/ObjectName}
    \end{center}
  \end{block}
  \begin{exampleblock}{Typical operations}
    All operations are carried out by sending HTTP requests:
    \begin{itemize}\tightlist
      \item Create a bucket/object: \code{PUT}, along with the URI
      \item Listing objects: \code{GET} on a bucket name
      \item Reading an object: \code{GET} on a full URI
    \end{itemize}
  \end{exampleblock}
\end{slide}
\section{Publish-subscribe architectures}

\begin{slide}{Publish and Subscribe}
  \textbf{Pub-Sub Model}: Publishers send messages to topics, subscribers receive them asynchronously.
  \begin{itemize}
    \item \textbf{Decoupling}: Publishers and subscribers operate independently, enhancing scalability.
    \item \textbf{Asynchronous Communication}: Messages are delivered without requiring immediate response.
    \item \textbf{Topics}: Messages are categorized into topics for targeted delivery.
    \item \textbf{Loose Coupling}: Reduces dependencies between system components.
    \item \textbf{Event-Driven}: Triggers actions based on message events.
  \end{itemize}\end{slide}
\begin{slide}{Publish and subscribe}
  \begin{block}{Issue: how to match events?}
    \begin{itemize}\firmlist
      \item Assume events are described by \textbf{(attribute,value)} pairs
      \item \textbf{topic-based subscription}: specify a ``\textbf{attribute = value}'' series
      \item \textbf{content-based subscription}: specify a ``\textbf{attribute \mathexpr{\in} range}'' series
    \end{itemize}
  \end{block}
  \centering\includefigure{02-12}
  \begin{alertblock}{Observation}
    Content-based subscriptions may easily have serious scalability problems (\textbf{why?})
  \end{alertblock}
\end{slide}

\section{Symmetrically distributed system architectures}
\begin{slide}{Alternative organizations}
  \begin{block}{Vertical distribution}
    Comes from dividing distributed applications into three logical layers, and running the components
    from each layer on a different server (machine).
  \end{block}
  \begin{block}{Horizontal distribution}
    A client or server may be physically split up into logically equivalent parts, but each part is operating
    on its own share of the complete data set.
  \end{block}
  \begin{block}{Peer-to-peer architectures}
    Processes are all equal: the functions that need to be carried out are represented by every process
    \mathexpr{\Rightarrow} each process will act as a client and a server at the same time (i.e.,
    acting as a \textbf{servant}).
  \end{block}
\end{slide}
\subsection{Structured peer-to-peer systems}
\begin{slide}{Structured P2P}
  \begin{block}{Essence}
    Make use of a \textbf{semantic-free index}: each data item is uniquely associated with a key, in turn used
    as an index. Common practice: use a \textbf{hash function}
    \vspace*{-6pt}
    \[ \func{key}(\func{data item}) = \func{hash}(\func{data item's value}). \vspace*{-6pt}\]
    P2P system now responsible for storing (\emph{key},\emph{value}) pairs.
  \end{block}
  \begin{exampleblock}{Simple example: hypercube}
    \begin{centerfig}
      \includefigure{02-23}
    \end{centerfig}
    Looking up \mathexpr{d} with \textbf{key} \mathexpr{k \in \{0,1,2,\ldots,2^4-1\}} means \textbf{routing}
    request to node with \textbf{identifier} \mathexpr{k}.
  \end{exampleblock}
\end{slide}
\begin{slide}{Example: Chord}
  \begin{block}{Principle}
    \begin{itemize}\tightlist
      \item Nodes are logically organized in a ring. Each node has an \mathexpr{m}-bit \textbf{identifier}.
      \item Each data item is hashed to an \mathexpr{m}-bit \textbf{key}.
      \item Data item with key \mathexpr{k} is stored at node with smallest identifier \mathexpr{\id{id} \geq
              k}, called the \textbf{successor} of key \mathexpr{k}.
      \item The ring is extended with various \textbf{shortcut links} to other nodes.
    \end{itemize}
  \end{block}
\end{slide}
\begin{slide}{Example: Chord}
  \begin{centerfig}
    \begin{tabular}{c}
      \includefigure{02-24} \\
      \mathexpr{\func{lookup}(3)@9: 28 \rightarrow 1 \rightarrow 4}
    \end{tabular}
  \end{centerfig}
\end{slide}
\subsection{Unstructured peer-to-peer systems}
\begin{slide}{Unstructured P2P}
  \begin{block}{Essence}
    Each node maintains an ad hoc list of neighbors. The resulting overlay resembles a \textbf{random graph}: an
    edge \mathexpr{\langle \id{u},\id{v} \rangle} exists only with a
    certain probability \mathexpr{\mathbb{P}[\langle \id{u}, \id{v} \rangle]}.
  \end{block}
  \begin{block}{Searching}
    \begin{itemize}
      \item \textbf{Flooding}: issuing node \id{u} passes request for \mathexpr{d} to all neighbors. Request is
            ignored when receiving node had seen it before. Otherwise, \id{v} searches locally for \mathexpr{d}
            (recursively). May be limited by a \textbf{Time-To-Live}: a maximum number of hops.
      \item \textbf{Random walk}: issuing node \id{u} passes request for \mathexpr{d} to randomly chosen neighbor,
            \id{v}. If \id{v} does not have \mathexpr{d}, it forwards request to one of \emph{its} randomly chosen
            neighbors, and so on.
    \end{itemize}
  \end{block}
\end{slide}
\begin{slide}{Flooding versus random walk}
  \begin{block}{Model}
    Assume \mathexpr{N} nodes and that each data item is replicated across \mathexpr{r} randomly chosen
    nodes.
  \end{block}
  \begin{block}{Random walk}
    \mathexpr{\mathbb{P}[k]} probability that item is found after \mathexpr{k} attempts:
    \[ \mathbb{P}[k] = \frac{r}{N}(1-\frac{r}{N})^{k-1}.\]
    \mathexpr{S} (``search size'') is expected number of nodes that need to be probed:
    \[ S = \sum_{k=1}^N k \cdot \mathbb{P}[k] = \sum_{k=1}^N k \cdot \frac{r}{N}(1-\frac{r}{N})^{k-1}
      \approx N/r \mbox{\ for \mathexpr{1 \ll r \leq N}}. \]
  \end{block}
\end{slide}
\begin{slide}{Flooding versus random walk}
  \begin{block}{Flooding}
    \begin{itemize}\tightlist
      \item Flood to \mathexpr{d} randomly chosen neighbors
      \item After \mathexpr{k} steps, some \mathexpr{R(k) = d \cdot (d-1)^{k-1}} will have been reached (assuming
            \mathexpr{k} is small).
      \item With fraction \mathexpr{r/N} nodes having data, if \mathexpr{\frac{r}{N}\cdot R(k) \geq 1}, we
            will have found the data item.
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Comparison}
    \begin{itemize}
      \item If \mathexpr{r/N = 0.001}, then \mathexpr{S \approx 1000}
      \item With flooding and \mathexpr{d = 10, k = 4}, we contact 7290 nodes.
      \item Random walks are more communication efficient, but might take longer before they find the result.
    \end{itemize}
  \end{exampleblock}
\end{slide}
\subsection{Hierarchically organized peer-to-peer networks}
% \begin{slide}{Super-peer networks}
%   \begin{block}{Essence}
%     It is sometimes sensible to break the symmetry in pure peer-to-peer networks:
%     \begin{itemize}\tightlist
%     \item When searching in unstructured P2P systems, having \textbf{index servers} improves performance
%     \item Deciding where to store data can often be done more efficiently through \textbf{brokers}.
%     \end{itemize}
%   \end{block}
%   \begin{centerfig}
%     \includefigure{02-25}
%   \end{centerfig}
% \end{slide}
% \subsection{Example: BitTorrent}
% \begin{slide}{Collaboration: The BitTorrent case}
%   \begin{block}{Principle: search for a file \id{F}}
%     \begin{itemize}\tightlist
%     \item Lookup file at a global directory \mathexpr{\Rightarrow} returns a \textbf{torrent file}
%     \item Torrent file contains reference to \textbf{tracker}: a server keeping an accurate account of
%       \textbf{active} nodes that have (chunks of) \id{F}.
%     \item \id{P} can join \textbf{swarm}, get a chunk for free, and then trade a copy of that chunk for another
%       one with a peer \id{Q} also in the swarm.
%     \end{itemize}
%   \end{block}
%   \begin{centerfig}
%     \includefigure{02-26}
%   \end{centerfig}
% \end{slide}
\section{Hybrid system architectures}
\subsection{Cloud computing}
\begin{slide}{Cloud computing}
  \begin{centerfig}
    \includefigure{02-27}
  \end{centerfig}
\end{slide}
\begin{slide}{Cloud computing}
  \begin{block}{Make a distinction between four layers}
    \begin{itemize}
      \item \textbf{Hardware}: Processors, routers, power and cooling systems. Customers normally never get to see these.
      \item \textbf{Infrastructure}: Deploys virtualization techniques. Evolves around allocating and managing
            virtual storage devices and virtual servers.
      \item \textbf{Platform}: Provides higher-level abstractions for storage and such. Example: Amazon S3 storage
            system offers an API for (locally created) files to be organized and stored in so-called \textbf{buckets}.
      \item \textbf{Application}: Actual applications, such as office suites (text processors, spreadsheet
            applications, presentation applications). Comparable to the suite of apps shipped with OSes.
    \end{itemize}
  \end{block}
\end{slide}
\subsection{The edge-cloud architecture}
\begin{slide}{Edge-server architecture}
  \begin{block}{Essence}
    Systems deployed on the Internet where servers are placed \textbf{at the edge} of the network:
    the boundary between enterprise networks and the actual Internet.
  \end{block}
  \begin{centerfig}
    \includefigure{02-28}
  \end{centerfig}
\end{slide}
\begin{slide}{Reasons for having an edge infrastructure}
  \begin{block}{Commonly (and often misconceived) arguments}
    \begin{itemize}
      \item \textbf{Latency and bandwidth}: Especially important for certain real-time applications, such as
            augmented/virtual reality applications. Many people underestimate the latency and bandwidth to the
            cloud.
      \item \textbf{Reliability}: The connection to the cloud is often assumed to be unreliable, which is often a
            false assumption. There may be critical situations in which extremely high connectivity guarantees are
            needed.
      \item \textbf{Security and privacy}: The implicit assumption is often that when assets are nearby, they can
            be made better protected. Practice shows that this assumption is generally false. However, securely
            handling data operations in the cloud may be trickier than within your own organization.
    \end{itemize}
  \end{block}
\end{slide}
\begin{slide}{Edge orchestration}
  \begin{block}{Managing resources at the edge may be trickier than in the cloud}
    \begin{itemize}\firmlist

      \item \textbf{Resource allocation}: we need to guarantee the availability of the resources required to
            perform a service.

      \item \textbf{Service placement}: we need to decide \textbf{when} and \textbf{where} to place a service. This is
            notably relevant for mobile applications.

      \item \textbf{Edge selection}: we need to decide which edge infrastructure should be
            used when a service needs to be offered. The closest one may not be the best one.
    \end{itemize}
  \end{block}

  \begin{alertblock}{Observation}
    There is still a lot of buzz about edge infrastructures and computing, yet whether all that buzz makes any
    sense remains to be seen.
  \end{alertblock}
\end{slide}
\section{Blockchain architectures}
\begin{slide}{Blockchains}
  \begin{block}{Principle working of a blockchain system}
    \centering\includefigure[0.65]{02-29}
  \end{block}
  \onslide
  \begin{block}{Observations}
    \begin{itemize}\firmlist
      \item Blocks are organized into an unforgeable \textbf{append-only} chain
      \item Each block in the blockchain is \textbf{immutable} \mathexpr{\Rightarrow} massive replication
      \item The real snag lies in who is allowed to append a block to a chain
    \end{itemize}

  \end{block}
\end{slide}
\begin{slide}{Appending a block: distributed consensus}
  \begin{block}{Centralized solution}
    \begin{centerfig}
      \includefigure{02-30a}
    \end{centerfig}
  \end{block}
  \begin{block}{Observation}
    A single entity decides on which validator can go ahead and append a block. Does not fit the design goals
    of blockchains.
  \end{block}
\end{slide}
\begin{slide}{Appending a block: distributed consensus}
  \begin{block}{Distributed solution (permissioned)}
    \begin{centerfig}
      \includefigure{02-30b}
    \end{centerfig}
  \end{block}
  \begin{block}{Observation}
    \begin{itemize}\firmlist
      \item A selected, relatively small group of servers jointly reach consensus on which validator can go
            ahead.
      \item None of these servers needs to be trusted, as long as roughly two-thirds behave according to their
            specifications.
      \item In practice, only a few tens of servers can be accommodated.
    \end{itemize}
  \end{block}
\end{slide}
\begin{slide}{Appending a block: distributed consensus}
  \begin{block}{Decentralized solution (permisionless)}
    \begin{centerfig}
      \includefigure{02-30c}
    \end{centerfig}
  \end{block}
  \begin{block}{Observation}
    \begin{itemize}\firmlist
      \item Participants collectively engage in a \textbf{leader election}. Only the elected leader is allowed to
            append a block of validated transactions.
      \item Large-scale, decentralized leader election that is fair, robust, secure, and so on, is far from
            trivial.
    \end{itemize}

  \end{block}
\end{slide}
\section{Summary}
\begin{slide}{Summary and Conclusions}
  We have discussed architectureal principles
  in Distributed Systems, namely:
  \begin{itemize}
    \item Layered
    \item RPC and RESTful styles
    \item Publish and Subscribe
    \item Structured and Unstructured P2P
    \item Cloud Edge Computing
    \item Blockchains
  \end{itemize}
  As with all topics on this course, please make sure
  you understand the \emph{why}, of each of these
  architectures, not just the \emph{how/what}
\end{slide}
